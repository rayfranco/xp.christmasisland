// Generated by CoffeeScript 1.3.3

/*
Head Tracking for Christmas Experiments http://christmasexperiments.com
by RayFranco http://twitter.com/RayFranco http://github.com/RayFranco

Credits :
	Music sampled for this project by Irsih Steph
	Skybox graphics by XXX
Libraries :
	Headtrackr
	Three.js
	Buzz

Thanks to BigYouth, grgdvrt, David Ronai and mr.doob for advices and help
Happy Birthday Caro <3

This is coded in CoffeeScript, you should have a look at the non-minified file 
here for more details
*/


(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  if (!(typeof $ !== "undefined" && $ !== null)) {
    throw "jQuery is not installed";
  }

  if (!(typeof buzz !== "undefined" && buzz !== null)) {
    throw "Buzz is not installed";
  }

  $(function() {
    var CAMERA_DISTANCE, FLAKES_COUNT, Flake, FlakeStorm, ballDown, ballUp, camera, composer, darkenScreen, directionalLight, effectColorify, effectFilm, effectVignette, geometry, htracker, light, lightenScreen, material, mesh, nerve, onFaceTrackingEvent, onHeadTrackrStatus, percentX, percentY, pointLight, rParameters, render, renderModel, renderer, rtParameters, scene, sceneCanvas, shader, smParameters, soundOptions, start, storm, textureCube, track1, track2, track3, trackerCanvas, trackerVideo, urlPrefix, urls, volume1, volume2, volume3;
    FLAKES_COUNT = 500;
    CAMERA_DISTANCE = 200;
    nerve = .5;
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 120000);
    camera.position.z = 200;
    camera.position.y = 0;
    scene.add(camera);
    sceneCanvas = document.getElementById('scene');
    rParameters = {
      canvas: sceneCanvas,
      clearColor: 0xFFFFFF,
      clearAlpha: 0,
      antialias: false,
      autoClear: false,
      gammaInput: true,
      gammaOutput: true,
      sort: false
    };
    renderer = new THREE.WebGLRenderer(rParameters);
    renderer.setSize(window.innerWidth, window.innerHeight);
    console.log(renderer);
    renderModel = new THREE.RenderPass(scene, camera);
    effectFilm = new THREE.FilmPass(3, 0.1, 0, true);
    effectVignette = new THREE.ShaderPass(THREE.VignetteShader);
    effectColorify = new THREE.ShaderPass(THREE.ColorifyShader);
    effectVignette.uniforms["offset"].value = 0.8;
    effectVignette.uniforms["darkness"].value = 2;
    effectVignette.renderToScreen = true;
    rtParameters = {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      format: THREE.RGBFormat,
      stencilBuffer: true
    };
    composer = new THREE.EffectComposer(renderer, new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, rtParameters));
    composer.addPass(renderModel);
    composer.addPass(effectFilm);
    composer.addPass(effectVignette);
    trackerCanvas = document.getElementById('trackerCanvas');
    trackerVideo = document.getElementById('trackerVideo');
    htracker = new headtrackr.Tracker({
      ui: false,
      headPosition: true,
      calcAngles: false
    });
    htracker.init(trackerVideo, trackerCanvas);
    htracker.start();
    urlPrefix = "assets/textures/skybox/";
    urls = [urlPrefix + "posx.jpg", urlPrefix + "negx.jpg", urlPrefix + "posy.jpg", urlPrefix + "negy.jpg", urlPrefix + "posz.jpg", urlPrefix + "negz.jpg"];
    textureCube = THREE.ImageUtils.loadTextureCube(urls);
    geometry = new THREE.SphereGeometry(100, 32, 16);
    material = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      envMap: textureCube
    });
    mesh = new THREE.Mesh(geometry, material);
    mesh.position.x = 0;
    mesh.position.y = 0;
    mesh.position.z = 0;
    mesh.scale.x = mesh.scale.y = mesh.scale.z = 1;
    scene.add(mesh);
    ballDown = new TWEEN.Tween(mesh.position).to({
      y: -20
    }, 5000).easing(TWEEN.Easing.Cubic.InOut);
    ballUp = new TWEEN.Tween(mesh.position).to({
      y: 20
    }, 5000).easing(TWEEN.Easing.Cubic.InOut);
    start = new TWEEN.Tween(mesh.position).to({
      y: 20
    }, 2500).start().chain(ballDown).easing(TWEEN.Easing.Cubic.Out);
    ballDown.chain(ballUp);
    ballUp.chain(ballDown);
    shader = THREE.ShaderUtils.lib["cube"];
    smParameters = {
      fragmentShader: shader.fragmentShader,
      vertexShader: shader.vertexShader,
      uniforms: shader.uniforms,
      depthWrite: false,
      side: THREE.BackSide
    };
    shader.uniforms['tCube'].value = textureCube;
    material = new THREE.ShaderMaterial(smParameters);
    mesh = new THREE.Mesh(new THREE.CubeGeometry(10000, 10000, 10000), material);
    scene.add(mesh);
    pointLight = new THREE.PointLight(0x0000FF);
    pointLight.position.x = 10;
    pointLight.position.y = 50;
    pointLight.position.z = 130;
    scene.add(pointLight);
    directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.x = 1;
    directionalLight.position.y = 1;
    directionalLight.position.z = 0;
    scene.add(directionalLight);
    light = new THREE.AmbientLight(0x666666);
    scene.add(light);
    FlakeStorm = (function() {

      function FlakeStorm(scene, subject, count) {
        var i, particle, _i, _ref;
        this.scene = scene;
        this.subject = subject;
        this.count = count;
        this.flakes = new THREE.Geometry();
        this.material = new THREE.ParticleBasicMaterial({
          size: 5,
          map: THREE.ImageUtils.loadTexture("assets/particle.png"),
          blending: THREE.AdditiveBlending,
          transparent: true
        });
        this.points = new THREE.GeometryUtils.randomPointsInGeometry(this.subject, this.count);
        for (i = _i = 0, _ref = this.count; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          this.points[i] = new THREE.Vector3(Math.random() * 400 - 200, Math.random() * 400 - 200, Math.random() * 2000 - 1000);
          particle = new Flake(this.points[i], 50);
          this.flakes.vertices.push(particle);
        }
        this.system = new THREE.ParticleSystem(this.flakes, this.material);
        this.system.sortParticles = true;
        this.scene.add(this.system);
        return this;
      }

      FlakeStorm.prototype.update = function() {
        var flake, _i, _len, _ref;
        _ref = this.flakes.vertices;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          flake = _ref[_i];
          if (flake.y < -200) {
            flake.y = 200;
          }
          if (flake.x < -200) {
            flake.x = 200;
          }
          if (flake.x > 200) {
            flake.x = -200;
          } else {
            flake.y -= 0.5 * Math.random();
            flake.x -= 0.5 * Math.random();
          }
        }
        return this.flakes.vertices.verticesNeedUpdate = true;
      };

      return FlakeStorm;

    })();
    Flake = (function(_super) {

      __extends(Flake, _super);

      function Flake(vector, r) {
        if (r == null) {
          r = 2;
        }
        this.velocity = new THREE.Vector3(0, -Math.random() + 1, 0);
        this.animation = null;
        this.x = vector.x;
        this.y = vector.y;
        this.z = vector.z;
        return this;
      }

      return Flake;

    })(THREE.Vector3);
    storm = new FlakeStorm(scene, geometry, FLAKES_COUNT);
    soundOptions = {
      preload: true,
      autoplay: false,
      loop: true
    };
    track1 = new buzz.sound('assets/loop1.wav', soundOptions);
    track2 = new buzz.sound('assets/loop2.wav', soundOptions);
    track3 = new buzz.sound('assets/loop3.wav', soundOptions);
    buzz.all().bindOnce('canplaythrough', function() {
      return buzz.all().play();
    });
    volume1 = 100;
    volume2 = 20;
    volume3 = 0;
    buzz.all();
    percentX = .5;
    percentY = .5;
    render = function() {
      var camX, camZ;
      TWEEN.update();
      storm.update();
      requestAnimationFrame(render);
      renderer.render(scene, camera);
      camera.lookAt({
        x: 0,
        y: 0,
        z: 0
      });
      camX = percentX * 400 - 200;
      camZ = Math.sqrt(Math.pow(200, 2) - Math.pow(camX, 2));
      new TWEEN.Tween(camera.position).to({
        x: camX
      }, 980).easing(TWEEN.Easing.Cubic.Out).start();
      composer.render(0.0001);
      track1.setVolume(volume1);
      track2.setVolume(volume2);
      return track3.setVolume(volume3);
    };
    render();
    onHeadTrackrStatus = function(e) {
      if (e.status === 'found') {
        return lightenScreen();
      } else if (e.status === 'lost' || e.status === 'redetecting') {
        return darkenScreen();
      }
    };
    onFaceTrackingEvent = function(e) {
      percentX = nerve = 1 - e.x / 318;
      percentY = 1 - e.y / 240;
      volume1(percentX * 100);
      volume2 = 100 - percentX * 100;
      return volume3(100 - percentX * 150);
    };
    document.addEventListener('headtrackrStatus', onHeadTrackrStatus);
    document.addEventListener('facetrackingEvent', onFaceTrackingEvent);
    darkenScreen = function() {
      var anim;
      anim = new TWEEN.Tween({
        grayscale: 0,
        nIntensity: 0.1
      }).to({
        grayscale: 1,
        nIntensity: 3
      }, 500).easing(TWEEN.Easing.Cubic.Out);
      anim.onUpdate(function() {
        effectFilm.uniforms["grayscale"].value = this.grayscale;
        return effectFilm.uniforms["nIntensity"].value = this.nIntensity;
      });
      return anim.start();
    };
    return lightenScreen = function() {
      var anim;
      anim = new TWEEN.Tween({
        grayscale: 1,
        nIntensity: 3
      }).to({
        grayscale: 0,
        nIntensity: 0.1
      }, 500).easing(TWEEN.Easing.Cubic.Out);
      anim.onUpdate(function() {
        effectFilm.uniforms["grayscale"].value = this.grayscale;
        return effectFilm.uniforms["nIntensity"].value = this.nIntensity;
      });
      return anim.start();
    };
  });

}).call(this);
