// Generated by CoffeeScript 1.3.3

/*
Head Tracking for Christmas Experiments http://christmasexperiments.com
by RayFranco http://twitter.com/RayFranco http://github.com/RayFranco

Credits :
	Music sampled for this project by Irsih Steph
	Skybox graphics by XXX
Libraries :
	Headtrackr
	Three.js
	Buzz

Thanks to BigYouth, grgdvrt, David Ronai and mr.doob for advices and help
Happy Birthday Caro <3

This is coded in CoffeeScript, you should have a look at the non-minified file 
here for more details
*/


(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  if (!(typeof $ !== "undefined" && $ !== null)) {
    throw "jQuery is not installed";
  }

  if (!(typeof buzz !== "undefined" && buzz !== null)) {
    throw "Buzz is not installed";
  }

  $(function() {
    var CAMERA_DISTANCE, CAM_Y, CAM_Z, EXPLORE_TIME, FAR, FLAKES_COUNT, Flake, FlakeStorm, MIN_EXPLORE, NEAR, PERSPECTIVE, ball, ballDown, ballUp, camera, composer, darkenScreen, detected, directionalLight, effectFilm, effectVignette, explored_l, explored_r, geometry, helpExplore, htracker, light, lightenScreen, material, mesh, nerve, onFaceTrackingEvent, onHeadTrackrStatus, onWindowResize, pointLight, rParameters, render, renderModel, renderer, rtParameters, scene, sceneCanvas, shader, smParameters, soundOptions, start, storm, textureCube, track1, track2, track3, trackX, trackY, trackerCanvas, trackerVideo, urlPrefix, urls, volume1, volume2, volume3;
    FLAKES_COUNT = 500;
    CAMERA_DISTANCE = 200;
    NEAR = 1;
    FAR = 120000;
    PERSPECTIVE = 75;
    CAM_Z = 200;
    CAM_Y = 0;
    MIN_EXPLORE = .5;
    EXPLORE_TIME = 5000;
    nerve = .1;
    explored_r = 0;
    explored_l = 0;
    detected = false;
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(PERSPECTIVE, window.innerWidth / window.innerHeight, NEAR, FAR);
    camera.position.z = CAM_Z;
    camera.position.y = CAM_Y;
    scene.add(camera);
    sceneCanvas = document.getElementById('scene');
    rParameters = {
      canvas: sceneCanvas,
      antialias: false
    };
    renderer = new THREE.WebGLRenderer(rParameters);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColorHex(0x000000, 0);
    renderer.autoClear = false;
    renderer.gammaInput = true;
    renderer.gammaOutput = true;
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderModel = new THREE.RenderPass(scene, camera);
    effectFilm = new THREE.FilmPass(3, 0.1, 0, true);
    effectVignette = new THREE.ShaderPass(THREE.VignetteShader);
    effectVignette.uniforms["offset"].value = 0.8;
    effectVignette.uniforms["darkness"].value = 2;
    effectVignette.renderToScreen = true;
    rtParameters = {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      stencilBuffer: true
    };
    composer = new THREE.EffectComposer(renderer, new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, rtParameters));
    composer.addPass(renderModel);
    composer.addPass(effectFilm);
    composer.addPass(effectVignette);
    trackerCanvas = document.getElementById('trackerCanvas');
    trackerVideo = document.getElementById('trackerVideo');
    htracker = new headtrackr.Tracker({
      ui: false,
      headPosition: true,
      calcAngles: false
    });
    htracker.init(trackerVideo, trackerCanvas);
    htracker.start();
    urlPrefix = "assets/textures/skybox/";
    urls = [urlPrefix + "posx.jpg", urlPrefix + "negx.jpg", urlPrefix + "posy.jpg", urlPrefix + "negy.jpg", urlPrefix + "posz.jpg", urlPrefix + "negz.jpg"];
    textureCube = THREE.ImageUtils.loadTextureCube(urls);
    geometry = new THREE.SphereGeometry(100, 32, 16);
    material = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      envMap: textureCube
    });
    ball = new THREE.Mesh(geometry, material);
    ball.position.x = 0;
    ball.position.y = 0;
    ball.position.z = 0;
    ball.scale.x = ball.scale.y = ball.scale.z = 1;
    scene.add(ball);
    ballDown = new TWEEN.Tween(ball.position).to({
      y: -20
    }, 5000).easing(TWEEN.Easing.Cubic.InOut);
    ballUp = new TWEEN.Tween(ball.position).to({
      y: 20
    }, 5000).easing(TWEEN.Easing.Cubic.InOut);
    start = new TWEEN.Tween(ball.position).to({
      y: 20
    }, 2500).start().chain(ballDown).easing(TWEEN.Easing.Cubic.Out);
    ballDown.chain(ballUp);
    ballUp.chain(ballDown);
    shader = THREE.ShaderUtils.lib["cube"];
    smParameters = {
      fragmentShader: shader.fragmentShader,
      vertexShader: shader.vertexShader,
      uniforms: shader.uniforms,
      depthWrite: false,
      side: THREE.BackSide
    };
    shader.uniforms['tCube'].value = textureCube;
    material = new THREE.ShaderMaterial(smParameters);
    mesh = new THREE.Mesh(new THREE.CubeGeometry(10000, 10000, 10000), material);
    scene.add(mesh);
    pointLight = new THREE.PointLight(0x0000FF);
    pointLight.position.x = 10;
    pointLight.position.y = 50;
    pointLight.position.z = 130;
    scene.add(pointLight);
    directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.x = 1;
    directionalLight.position.y = 1;
    directionalLight.position.z = 0;
    scene.add(directionalLight);
    light = new THREE.AmbientLight(0x666666);
    scene.add(light);
    FlakeStorm = (function() {

      function FlakeStorm(scene, subject, count) {
        var i, particle, _i, _ref;
        this.scene = scene;
        this.subject = subject;
        this.count = count;
        this.flakes = new THREE.Geometry();
        this.material = new THREE.ParticleBasicMaterial({
          size: 5,
          map: THREE.ImageUtils.loadTexture("assets/particle.png"),
          blending: THREE.AdditiveBlending,
          transparent: true
        });
        this.points = new THREE.GeometryUtils.randomPointsInGeometry(this.subject, this.count);
        for (i = _i = 0, _ref = this.count; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          this.points[i] = new THREE.Vector3(Math.random() * 400 - 200, Math.random() * 400 - 200, Math.random() * 2000 - 1000);
          particle = new Flake(this.points[i], 50);
          this.flakes.vertices.push(particle);
        }
        this.system = new THREE.ParticleSystem(this.flakes, this.material);
        this.system.sortParticles = true;
        this.scene.add(this.system);
        return this;
      }

      FlakeStorm.prototype.update = function() {
        var flake, _i, _len, _ref;
        _ref = this.flakes.vertices;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          flake = _ref[_i];
          if (flake.y < -200) {
            flake.y = 200;
          }
          if (flake.x < -200) {
            flake.x = 200;
          }
          if (flake.x > 200) {
            flake.x = -200;
          } else {
            flake.y -= 50 * Math.random() * nerve;
            flake.x -= 20 * Math.random() * nerve;
          }
        }
        return this.flakes.vertices.verticesNeedUpdate = true;
      };

      return FlakeStorm;

    })();
    Flake = (function(_super) {

      __extends(Flake, _super);

      function Flake(vector, r) {
        if (r == null) {
          r = 2;
        }
        this.velocity = new THREE.Vector3(0, -Math.random() + 1, 0);
        this.animation = null;
        this.x = vector.x;
        this.y = vector.y;
        this.z = vector.z;
        return this;
      }

      return Flake;

    })(THREE.Vector3);
    storm = new FlakeStorm(scene, geometry, FLAKES_COUNT);
    soundOptions = {
      preload: true,
      autoplay: false,
      loop: true
    };
    track3 = new buzz.sound('assets/loop1.wav', soundOptions);
    track2 = new buzz.sound('assets/loop2.wav', soundOptions);
    track1 = new buzz.sound('assets/loop3.wav', soundOptions);
    buzz.all().bindOnce('canplaythrough', function() {
      return buzz.all().play();
    });
    volume1 = 100;
    volume2 = 50;
    volume3 = 0;
    trackX = .5;
    trackY = .5;
    render = function() {
      var camX, camZ;
      requestAnimationFrame(render);
      TWEEN.update();
      storm.update();
      camera.lookAt({
        x: 0,
        y: 0,
        z: 0
      });
      camX = trackX * 400 - 200;
      camZ = Math.sqrt(Math.pow(201, 2) - Math.pow(camX, 2));
      new TWEEN.Tween(camera.position).to({
        x: camX,
        z: camZ
      }, 980).easing(TWEEN.Easing.Cubic.Out).start();
      if (nerve > .5) {
        ball.material.color.setRGB(1, 1 - (2 * nerve - 1), 1 - (2 * nerve - 1));
      } else {
        ball.material.color.setRGB(1, 1, 1);
      }
      track1.setVolume(volume1);
      track2.setVolume(volume2);
      track3.setVolume(volume3);
      renderer.render(scene, camera);
      return composer.render(0.005);
    };
    render();
    onHeadTrackrStatus = function(e) {
      if (e.status === 'found') {
        detected = true;
        lightenScreen();
        return setTimeout(helpExplore, EXPLORE_TIME);
      } else if (e.status === 'lost' || e.status === 'redetecting') {
        detected = false;
        return darkenScreen();
      }
    };
    onFaceTrackingEvent = function(e) {
      var nexplored_l, nexplored_r;
      trackX = nerve = 1 - e.x / 318;
      trackY = 1 - e.y / 240;
      if (trackX > .5) {
        nexplored_r = trackX * 2 - .5;
        if (explored_r < nexplored_r) {
          explored_r = nexplored_r;
        }
      } else {
        nexplored_l = trackX * 2;
        if (explored_l < nexplored_l) {
          explored_l = nexplored_l;
        }
      }
      volume1 = trackX * 100;
      volume2 = -100 * Math.cos(trackX * Math.PI * 1.5);
      return volume3 = 100 - trackX * 150;
    };
    onWindowResize = function(e) {
      renderer.setSize(window.innerWidth, window.innerHeight);
      sceneCanvas.style.height = window.innerHeight + 'px';
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      return composer.reset(new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, rtParameters));
    };
    helpExplore = function() {
      console.log('explore', explored_l, explored_r);
      if (explored_l < MIN_EXPLORE) {
        console.log('Step on your left !');
      }
      if (explored_r < MIN_EXPLORE) {
        return console.log('Step on your right !');
      }
    };
    darkenScreen = function() {
      var anim;
      anim = new TWEEN.Tween({
        grayscale: 0,
        nIntensity: 0.3
      }).to({
        grayscale: 1,
        nIntensity: 3
      }, 500).easing(TWEEN.Easing.Cubic.Out);
      anim.onUpdate(function() {
        effectFilm.uniforms["grayscale"].value = this.grayscale;
        return effectFilm.uniforms["nIntensity"].value = this.nIntensity;
      });
      return anim.start();
    };
    lightenScreen = function() {
      var anim;
      anim = new TWEEN.Tween({
        grayscale: 1,
        nIntensity: 3
      }).to({
        grayscale: 0,
        nIntensity: 0.3
      }, 500).easing(TWEEN.Easing.Cubic.Out);
      anim.onUpdate(function() {
        effectFilm.uniforms["grayscale"].value = this.grayscale;
        return effectFilm.uniforms["nIntensity"].value = this.nIntensity;
      });
      return anim.start();
    };
    document.addEventListener('headtrackrStatus', onHeadTrackrStatus);
    document.addEventListener('facetrackingEvent', onFaceTrackingEvent);
    return window.addEventListener('resize', onWindowResize);
  });

}).call(this);
